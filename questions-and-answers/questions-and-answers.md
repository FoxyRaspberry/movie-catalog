# Вопросы и ответы

## 1. Как вы можете описать процесс распространения событий в JavaScript (Event Propagation)? Расскажите о его основных фазах. Какие есть способы применения знаний о фазах распространения событий на практике?

Есть три фазы.
Погружение (захват), основная (целевая), всплытие.
Погружение (захват).
Событие опускается с самого верха вниз по DOM-дереву до элемента, на котором оно произошло.
Основная (целевая).
Событие достигает элемента, который его вызвал.
Обработчики, прикрепленные к этому элементу, выполняются на этом этапе.
Всплытие.
Событие поднимается обратно вверх, от целевого элемента к родителям, и так далее до `document` и `window`.

На практике знания о фазах распространения событий будет полезно при управлении обработкой событий, при делегировании событий, при создании пользовательских интерфейсов, при отладке.

## 2. Расскажите, что такое Promise в JavaScript, как он работает, какие основные состояния у него бывают? Каким еще способом можно обработать асинхронный код? Какую роль в асинхронности играет событийный цикл (Event Loop)?

`Promise` - это объект, представляющий результат асинхронной операции, который «обещает» предоставить значение или ошибку в будущем, позволяя управлять асинхронным кодом, избегая «ада коллбэков» (callback hell) и делая код более читаемым.

Как работает.
Создается Promise-объект с помощью `new Promise((resolve, reject) => { ... })`.
Внутри функции-конструктора происходит асинхронная операция (например, запрос к API, чтение файла).
Если операция успешна, вызывается `resolve(value)`, переводя промис в состояние `fulfilled` и передавая результат.
Если происходит ошибка, вызывается `reject(error)`, переводя промис в состояние `rejected`.
К промису подключаются обработчики с помощью методов `.then()` (для успешного выполнения) и `.catch()` (для ошибок) или `.finally()` (для любого завершения).

### Основные состояния Promise

* Pending (Ожидание): Начальное состояние. Промис создан, но операция еще не завершена.
* Fulfilled (Выполнено/Решено): Операция успешно завершена, и Promise имеет результат/значение.
* Rejected (Отклонено): Операция завершилась с ошибкой, и Promise имеет причину ошибки.

Состояния `fulfilled` и `rejected` являются конечными, и промис не может переходить между ними или обратно в `pending`. 

### Каким еще способом можно обработать асинхронный код?

Callback-функции: Функции, передаваемые как аргументы, которые вызываются после завершения асинхронной операции.
Метод простой, его не рекомендуют использовать.

Async/Await: Синтаксический сахар для работы с Promises, позволяющий писать асинхронный код как синхронный.
Это делает код более читаемым и понятным.

### Какую роль в асинхронности играет событийный цикл (Event Loop)?

Event Loop управляет асинхронным поведением JavaScript.
Он отвечает за обработку асинхронных задач и распределение ресурсов, разрешая их выполнение в основном потоке.

Очереди задач: Каждое асинхронное действие (например, Promise) помещается в соответствующую очередь задач, которую обрабатывает Event Loop.
Обработка задач: Event Loop постоянно проверяет, есть ли задачи в очереди, и извлекает их для выполнения, когда основной поток свободен.
Приоритет событий: Важно понимать, что другие задачи (например, таймеры, события, сетевые запросы) помещаются в разные очереди.
Event Loop обрабатывает их в порядке, в котором они были добавлены.

## 3. Что такое ООП, и какие его ключевые принципы вы могли бы описать? При объяснении приводите примеры. Максимально подробно расскажите о том, как ООП реализовано в JavaScript.

Объектно-ориентированное программирование - это организация кода в виде объектов, в которых одновременно содержатся данные (состояния) и описание методов работы (поведение). 

### Принципы

Инкапсуляция.
Написание кода таким образом, что вся механика скрыта из общего доступа, а работа происходит при помощи определенных методов.
Это помогает защитить внутренние состояния объектов.
Например, у объекта "пользователь" может быть метод, который возвращает информацию о пользователе, но сам доступ к полям (например, возраст или имя) ограничен.
Это защищает данные и позволяет изменять внутреннюю реализацию без влияния на внешний код.

Полиморфизм.
Позволяет объектам различных классов обрабатывать одно и то же сообщение (вызывать один и тот же метод) по-разному в зависимости от их типа.
Это повышает гибкость и расширяемость кода.
Например, у вас есть базовый класс "Фигура" и производные классы "Круг" и "Квадрат".
Метод, который вычисляет площадь, будет работать по-разному для каждого из этих классов: один будет использовать формулу для круга, а другой — для квадрата.

Наследование.
Создание нового класса на основе существующего, заимствуя его свойства и методы.
Помогает расширить функциональность без дублирования кода.
Например, если у вас есть класс "Животное" с общими свойствами (такими как имя и способ передвижения), вы можете создать класс "Собака", который будет наследовать эти свойства.
При этом "Собака" может добавить свои уникальные характеристики (например, лай) или изменить поведение, определенное в родительском классе.

Абстракция.
Заключается в выделении основных характеристик объекта и игнорировании деталей, которые не важны для текущих целей.
Это позволяет сосредоточиться на более высоком уровне проектирования.
Например, в классе "Автомобиль" можно определить основные характеристики, такие как марка, модель и скорость, исключая при этом подробности о конструкции двигателя.

JavaScript поддерживает ООП через прототипное наследование, а также через синтаксис классов, который был введен в ES6.

Прототипное наследование.
Каждый объект в JavaScript имеет внутреннюю ссылку на другой объект, называемый прототипом.
Это позволяет объектам наследовать свойства и методы от других объектов.

Синтаксис классов.
Синтаксис классов в JavaScript предоставляет более ясный и распространенный способ определения классов и их методов.
Он упрощает концепцию наследования и инкапсуляции.

## 4. Опишите максимально детально, как браузер обрабатывает URL, начиная с момента его ввода в адресную строку и заканчивая отображением страницы. Какие технологии позволяют ускорить процесс? Какие проблемы (безопасность, междоменное взаимодействие) могут возникать в процессе?

1. Ввод URL в адресную строку. Пользователь вводит URL в адресной строке браузера. Браузер сразу же начинает разбирать URL и проверяет, есть ли такой адрес уже в кэше.
2. Поиск в кэше. Браузер проверяет, находится ли запрашиваемый ресурс в кэше. Если ресурс кэшируется, его не нужно будет загружать заново. Если ресурс найден, он загружается непосредственно из кэша, что значительно ускоряет процесс.
3. Если ресурс не найден в кэше, браузер обращается к DNS-серверу для преобразования доменного имени (например, www.example.com) в IP-адрес. Этот процесс включает следующие шаги:
    - Браузер сначала проверяет DNS-кэш на локальном устройстве.
    - Если IP-адрес не найден, запрос отправляется к DNS-серверу, который может быть настроен пользователем или по умолчанию (например, Google DNS или ISP DNS).
    - DNS-сервер отвечает IP-адресом запрашиваемого домена.
4. Установление соединения. Как только IP-адрес определен, браузер устанавливает сетевое соединение с сервером. Используются протоколы передачи данных, такие как TCP (Transmission Control Protocol), для обеспечения надежной передачи данных.
5. Отправка HTTP-запроса. Браузер отправляет HTTP-запрос (например, GET) на сервер, включая заголовки, такие как User-Agent, Accept и другие.
6. Обработка сервером и ответ. Сервер обрабатывает запрос, выполняя необходимые действия (например, обращение к базе данных) и отправляет ответ, содержащий запрашиваемую страницу. Ответ включает HTTP статус-код (например, 200, 404).
7. Получение и обработка ответа. Браузер получает ответ от сервера и начинает его обрабатывать. Если страница HTML содержит ссылки на другие ресурсы (CSS, JavaScript, изображения), браузер отправляет дополнительные HTTP-запросы для их загрузки.
8. Разбор HTML и построение DOM. Браузер начинает разбирать HTML-страницу, создавая DOM (Document Object Model). Этот объект представляет структуру документа и позволяет браузеру управлять его содержимым.
9. Применение CSS и построение CSSOM. Браузер загружает и разбирает CSS, создавая CSSOM (CSS Object Model), который хранит стили и применяет их к элементам DOM.
10. Создание Render Tree. Браузер комбинирует DOM и CSSOM для создания Render Tree, в котором содержатся только элементы, которые должны быть видимыми, и их соответствующие стили.
11. Расчет макета. Браузер рассчитывает, как элементы будут размещены на экране, определяя размеры, позиции и т.д.
12. Отрисовка страницы. После расчета макета браузер отрисовывает визуальное представление страницы на экране.
13. Выполнение JavaScript. В процессе отрисовки браузер выполняет JavaScript-код, который может изменять DOM и CSSOM. Это может вызвать перерендеринг страницы.

### Какие технологии позволяют ускорить процесс?

Кэш, новые версии протокола HTTP обеспечивают более быструю обработку соединений, CDN (сети CDN ставят копии контента ближе к пользователям, что уменьшает время загрузки), сжатие и минификация (сжатие ресурсов (CSS и JavaScript) и минификация (удаление неиспользуемого кода) помогают уменьшить объем).
